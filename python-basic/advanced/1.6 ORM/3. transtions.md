# äº‹åŠ¡ä¸å¹¶å‘æ§åˆ¶
## ğŸ’° **é“¶è¡Œè½¬è´¦æ¡ˆä¾‹ï¼šäº‹åŠ¡çš„ACIDç‰¹æ€§**

---

### ğŸ”’ **åŸºç¡€äº‹åŠ¡ç®¡ç†**

```python
class BankTransactionService:
    """é“¶è¡Œäº¤æ˜“æœåŠ¡ - æ¼”ç¤ºäº‹åŠ¡ç®¡ç†"""
    
    def __init__(self, session: Session):
        self.session = session
    
    def transfer_money_basic(self, from_account: str, to_account: str, amount: float) -> bool:
        """åŸºç¡€è½¬è´¦å®ç° - å­˜åœ¨å¹¶å‘é—®é¢˜"""
        try:
            # 1. æŸ¥è¯¢è½¬å‡ºè´¦æˆ·
            from_acc = self.session.query(BankAccount).filter(
                BankAccount.account_number == from_account
            ).with_for_update().first()  # æ‚²è§‚é”
            
            if not from_acc:
                raise ValueError(f"è½¬å‡ºè´¦æˆ·ä¸å­˜åœ¨: {from_account}")
            
            # 2. æŸ¥è¯¢è½¬å…¥è´¦æˆ·
            to_acc = self.session.query(BankAccount).filter(
                BankAccount.account_number == to_account
            ).with_for_update().first()  # æ‚²è§‚é”
            
            if not to_acc:
                raise ValueError(f"è½¬å…¥è´¦æˆ·ä¸å­˜åœ¨: {to_account}")
            
            # 3. æ£€æŸ¥ä½™é¢
            if from_acc.balance < amount:
                raise ValueError(f"ä½™é¢ä¸è¶³: {from_acc.balance} < {amount}")
            
            # 4. æ‰§è¡Œè½¬è´¦
            from_acc.balance -= amount
            to_acc.balance += amount
            
            # 5. æäº¤äº‹åŠ¡
            self.session.commit()
            print(f"âœ… è½¬è´¦æˆåŠŸ: {from_account} -> {to_account} é‡‘é¢: {amount}")
            return True
            
        except Exception as e:
            # 6. å‘ç”Ÿé”™è¯¯æ—¶å›æ»š
            self.session.rollback()
            print(f"âŒ è½¬è´¦å¤±è´¥: {e}")
            return False
    
    def create_account(self, account_number: str, holder: str, initial_balance: float = 0) -> bool:
        """åˆ›å»ºé“¶è¡Œè´¦æˆ·"""
        try:
            account = BankAccount(
                account_number=account_number,
                account_holder=holder,
                balance=initial_balance
            )
            self.session.add(account)
            self.session.commit()
            print(f"âœ… åˆ›å»ºè´¦æˆ·æˆåŠŸ: {account_number}")
            return True
        except IntegrityError:
            self.session.rollback()
            print(f"âŒ è´¦æˆ·å·²å­˜åœ¨: {account_number}")
            return False

def test_basic_transaction():
    """æµ‹è¯•åŸºç¡€äº‹åŠ¡åŠŸèƒ½"""
    print("=== åŸºç¡€äº‹åŠ¡æµ‹è¯• ===")
    
    with SessionLocal() as session:
        service = BankTransactionService(session)
        
        # åˆ›å»ºæµ‹è¯•è´¦æˆ·
        service.create_account("ACC001", "Alice", 1000.0)
        service.create_account("ACC002", "Bob", 500.0)
        
        # æ‰§è¡Œè½¬è´¦
        service.transfer_money_basic("ACC001", "ACC002", 200.0)
        
        # éªŒè¯ç»“æœ
        acc1 = session.query(BankAccount).filter_by(account_number="ACC001").first()
        acc2 = session.query(BankAccount).filter_by(account_number="ACC002").first()
        
        print(f"ğŸ“Š è½¬è´¦åä½™é¢:")
        print(f"  ğŸ‘© Alice ({acc1.account_number}): {acc1.balance}")
        print(f"  ğŸ‘¨ Bob ({acc2.account_number}): {acc2.balance}")

# test_basic_transaction()
```

---

## âš¡ **å¹¶å‘é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ**

### **1. ä¸¢å¤±æ›´æ–°é—®é¢˜æ¼”ç¤º**

```python
class ConcurrencyTestService:
    """å¹¶å‘æµ‹è¯•æœåŠ¡"""
    
    def demonstrate_lost_update_problem(self):
        """æ¼”ç¤ºä¸¢å¤±æ›´æ–°é—®é¢˜"""
        print("=== ä¸¢å¤±æ›´æ–°é—®é¢˜æ¼”ç¤º ===")
        
        def concurrent_update(account_num: str, thread_id: int):
            """å¹¶å‘æ›´æ–°å‡½æ•°"""
            with SessionLocal() as session:
                try:
                    # è¯»å–è´¦æˆ·
                    account = session.query(BankAccount).filter_by(
                        account_number=account_num
                    ).first()
                    
                    if account:
                        # æ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†æ—¶é—´
                        time.sleep(0.1)
                        
                        # æ›´æ–°ä½™é¢ï¼ˆå­˜åœ¨ä¸¢å¤±æ›´æ–°é£é™©ï¼‰
                        new_balance = account.balance + 100
                        account.balance = new_balance
                        
                        session.commit()
                        print(f"ğŸ§µ çº¿ç¨‹ {thread_id} æ›´æ–°æˆåŠŸ: ä½™é¢ {new_balance}")
                    
                except Exception as e:
                    session.rollback()
                    print(f"âŒ çº¿ç¨‹ {thread_id} æ›´æ–°å¤±è´¥: {e}")
        
        # åˆ›å»ºæµ‹è¯•è´¦æˆ·
        with SessionLocal() as session:
            test_account = BankAccount(
                account_number="TEST001",
                account_holder="Test User",
                balance=1000.0
            )
            session.add(test_account)
            session.commit()
        
        # å¯åŠ¨å¤šä¸ªçº¿ç¨‹å¹¶å‘æ›´æ–°
        threads = []
        for i in range(5):
            thread = threading.Thread(
                target=concurrent_update,
                args=("TEST001", i)
            )
            threads.append(thread)
            thread.start()
        
        # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for thread in threads:
            thread.join()
        
        # æ£€æŸ¥æœ€ç»ˆç»“æœ
        with SessionLocal() as session:
            final_account = session.query(BankAccount).filter_by(
                account_number="TEST001"
            ).first()
            print(f"ğŸ“Š æœ€ç»ˆä½™é¢: {final_account.balance}")
            print(f"ğŸ’¡ æœŸæœ›ä½™é¢: {1000.0 + 100 * 5}")
            print(f"ğŸ” ä¸¢å¤±æ›´æ–°é‡: {1000.0 + 100 * 5 - final_account.balance}")

# åˆ›å»ºæµ‹è¯•å®ä¾‹å¹¶è¿è¡Œ
# test_service = ConcurrencyTestService()
# test_service.demonstrate_lost_update_problem()
```

### **2. ä¹è§‚é”è§£å†³æ–¹æ¡ˆ**

```python
class OptimisticLockingService:
    """ä¹è§‚é”è§£å†³æ–¹æ¡ˆ"""
    
    def transfer_money_optimistic(self, from_account: str, to_account: str, amount: float, max_retries: int = 3) -> bool:
        """ä½¿ç”¨ä¹è§‚é”çš„è½¬è´¦å®ç°"""
        
        for attempt in range(max_retries):
            try:
                with SessionLocal() as session:
                    # ä½¿ç”¨ç‰ˆæœ¬å·è¿›è¡Œä¹è§‚é”æ§åˆ¶
                    stmt = select(BankAccount).where(
                        BankAccount.account_number.in_([from_account, to_account])
                    ).with_for_update()  # ä»ç„¶éœ€è¦æ‚²è§‚é”é˜²æ­¢å…¶ä»–å¹¶å‘é—®é¢˜
                    
                    accounts = session.execute(stmt).scalars().all()
                    
                    from_acc = next((acc for acc in accounts if acc.account_number == from_account), None)
                    to_acc = next((acc for acc in accounts if acc.account_number == to_account), None)
                    
                    if not from_acc or not to_acc:
                        raise ValueError("è´¦æˆ·ä¸å­˜åœ¨")
                    
                    if from_acc.balance < amount:
                        raise ValueError("ä½™é¢ä¸è¶³")
                    
                    # æ£€æŸ¥ç‰ˆæœ¬å·ï¼ˆä¹è§‚é”ï¼‰
                    current_version_from = from_acc.version
                    current_version_to = to_acc.version
                    
                    # æ‰§è¡Œæ›´æ–°
                    from_acc.balance -= amount
                    from_acc.version += 1
                    
                    to_acc.balance += amount
                    to_acc.version += 1
                    
                    # ä½¿ç”¨ç‰ˆæœ¬å·ä½œä¸ºæ¡ä»¶æ›´æ–°
                    update_from_stmt = (
                        update(BankAccount)
                        .where(
                            and_(
                                BankAccount.account_number == from_account,
                                BankAccount.version == current_version_from
                            )
                        )
                        .values(balance=from_acc.balance, version=from_acc.version)
                    )
                    
                    update_to_stmt = (
                        update(BankAccount)
                        .where(
                            and_(
                                BankAccount.account_number == to_account,
                                BankAccount.version == current_version_to
                            )
                        )
                        .values(balance=to_acc.balance, version=to_acc.version)
                    )
                    
                    # æ‰§è¡Œæ›´æ–°
                    session.execute(update_from_stmt)
                    session.execute(update_to_stmt)
                    
                    session.commit()
                    print(f"âœ… è½¬è´¦æˆåŠŸ (å°è¯• {attempt + 1}): {from_account} -> {to_account} é‡‘é¢: {amount}")
                    return True
                    
            except Exception as e:
                print(f"âš ï¸ è½¬è´¦å°è¯• {attempt + 1} å¤±è´¥: {e}")
                if attempt == max_retries - 1:
                    print(f"âŒ è½¬è´¦å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°: {max_retries}")
                    return False
                # æŒ‡æ•°é€€é¿
                time.sleep(2 ** attempt)
        
        return False
    
    def test_optimistic_lock(self):
        """æµ‹è¯•ä¹è§‚é”"""
        print("=== ä¹è§‚é”æµ‹è¯• ===")
        
        # åˆ›å»ºæµ‹è¯•è´¦æˆ·
        with SessionLocal() as session:
            service = BankTransactionService(session)
            service.create_account("OPT001", "Optimistic User 1", 1000.0)
            service.create_account("OPT002", "Optimistic User 2", 1000.0)
        
        # æ¨¡æ‹Ÿå¹¶å‘è½¬è´¦
        def concurrent_transfer(thread_id: int):
            """å¹¶å‘è½¬è´¦å‡½æ•°"""
            success = self.transfer_money_optimistic("OPT001", "OPT002", 100.0)
            if success:
                print(f"ğŸ§µ çº¿ç¨‹ {thread_id} è½¬è´¦æˆåŠŸ")
            else:
                print(f"âŒ çº¿ç¨‹ {thread_id} è½¬è´¦å¤±è´¥")
        
        # å¯åŠ¨å¤šä¸ªå¹¶å‘çº¿ç¨‹
        threads = []
        for i in range(5):
            thread = threading.Thread(target=concurrent_transfer, args=(i,))
            threads.append(thread)
            thread.start()
        
        for thread in threads:
            thread.join()
        
        # éªŒè¯æœ€ç»ˆç»“æœ
        with SessionLocal() as session:
            acc1 = session.query(BankAccount).filter_by(account_number="OPT001").first()
            acc2 = session.query(BankAccount).filter_by(account_number="OPT002").first()
            
            print(f"ğŸ“Š æœ€ç»ˆä½™é¢:")
            print(f"  è´¦æˆ·1: {acc1.balance}, ç‰ˆæœ¬: {acc1.version}")
            print(f"  è´¦æˆ·2: {acc2.balance}, ç‰ˆæœ¬: {acc2.version}")

# æµ‹è¯•ä¹è§‚é”
# optimistic_service = OptimisticLockingService()
# optimistic_service.test_optimistic_lock()
```

---

## ğŸ—ï¸ **é«˜çº§äº‹åŠ¡æ¨¡å¼**

### **1. åµŒå¥—äº‹åŠ¡ä¸ä¿å­˜ç‚¹**

```python
class AdvancedTransactionService:
    """é«˜çº§äº‹åŠ¡æ¨¡å¼"""
    
    @contextmanager
    def transaction_with_savepoint(self, session: Session) -> Generator[Any, None, None]:
        """å¸¦ä¿å­˜ç‚¹çš„äº‹åŠ¡ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        savepoint_name = f"savepoint_{int(time.time())}"
        
        try:
            # åˆ›å»ºä¿å­˜ç‚¹
            session.begin_nested()
            print(f"ğŸ“ åˆ›å»ºä¿å­˜ç‚¹: {savepoint_name}")
            yield session
            
            # æäº¤åµŒå¥—äº‹åŠ¡
            session.commit()
            print(f"âœ… ä¿å­˜ç‚¹æäº¤: {savepoint_name}")
            
        except Exception as e:
            # å›æ»šåˆ°ä¿å­˜ç‚¹
            session.rollback()
            print(f"â†©ï¸ å›æ»šåˆ°ä¿å­˜ç‚¹: {savepoint_name}, åŸå› : {e}")
            raise
    
    def complex_business_operation(self):
        """å¤æ‚ä¸šåŠ¡æ“ä½œæ¼”ç¤º"""
        print("=== å¤æ‚ä¸šåŠ¡æ“ä½œæ¼”ç¤º ===")
        
        with SessionLocal() as session:
            try:
                # ä¸»äº‹åŠ¡å¼€å§‹
                session.begin()
                
                # æ­¥éª¤1: åˆ›å»ºè´¦æˆ·
                service = BankTransactionService(session)
                service.create_account("COMPLEX001", "Complex User 1", 2000.0)
                service.create_account("COMPLEX002", "Complex User 2", 1000.0)
                
                # æ­¥éª¤2: ä½¿ç”¨ä¿å­˜ç‚¹è¿›è¡Œå¤æ‚æ“ä½œ
                with self.transaction_with_savepoint(session):
                    # ç¬¬ä¸€æ¬¡è½¬è´¦
                    service.transfer_money_basic("COMPLEX001", "COMPLEX002", 500.0)
                    
                    # ç¬¬äºŒæ¬¡è½¬è´¦ï¼ˆå¯èƒ½å¤±è´¥ï¼‰
                    try:
                        service.transfer_money_basic("COMPLEX002", "COMPLEX001", 2000.0)  # ä¼šå¤±è´¥
                    except ValueError as e:
                        print(f"ğŸ’¡ é¢„æœŸä¸­çš„å¤±è´¥: {e}")
                        # è¿™é‡Œä¼šå›æ»šåˆ°ä¿å­˜ç‚¹ï¼Œä½†ä¸»äº‹åŠ¡ç»§ç»­
                
                # æ­¥éª¤3: ç»§ç»­å…¶ä»–æ“ä½œ
                service.transfer_money_basic("COMPLEX001", "COMPLEX002", 300.0)
                
                # æäº¤ä¸»äº‹åŠ¡
                session.commit()
                print("âœ… å¤æ‚ä¸šåŠ¡æ“ä½œå®Œæˆ")
                
            except Exception as e:
                session.rollback()
                print(f"âŒ ä¸šåŠ¡æ“ä½œå¤±è´¥: {e}")
    
    def demonstrate_transaction_isolation(self):
        """æ¼”ç¤ºäº‹åŠ¡éš”ç¦»çº§åˆ«"""
        print("=== äº‹åŠ¡éš”ç¦»çº§åˆ«æ¼”ç¤º ===")
        
        def read_uncommitted_reader():
            """è¯»æœªæäº¤çš„è¯»å–è€…ï¼ˆæ¨¡æ‹Ÿï¼‰"""
            with SessionLocal() as session:
                # è®¾ç½®éš”ç¦»çº§åˆ«ï¼ˆSQLiteä¸æ”¯æŒï¼Œè¿™é‡Œåªæ˜¯æ¼”ç¤ºï¼‰
                # session.connection().execution_options(isolation_level="READ UNCOMMITTED")
                
                account = session.query(BankAccount).filter_by(account_number="ISOLATION001").first()
                if account:
                    print(f"ğŸ‘€ è¯»æœªæäº¤è¯»å–: ä½™é¢ {account.balance}")
        
        with SessionLocal() as session:
            # åˆ›å»ºæµ‹è¯•è´¦æˆ·
            account = BankAccount(
                account_number="ISOLATION001",
                account_holder="Isolation Test",
                balance=1000.0
            )
            session.add(account)
            session.commit()
            
            # å¼€å§‹äº‹åŠ¡ä½†æœªæäº¤
            session.begin()
            account.balance = 1500.0  # ä¿®æ”¹ä½†æœªæäº¤
            
            # åœ¨å¦ä¸€ä¸ª"ä¼šè¯"ä¸­è¯»å–ï¼ˆæ¨¡æ‹Ÿè¯»æœªæäº¤ï¼‰
            read_uncommitted_reader()
            
            # å›æ»šä¿®æ”¹
            session.rollback()
            
            # æœ€ç»ˆè¯»å–
            final_account = session.query(BankAccount).filter_by(account_number="ISOLATION001").first()
            print(f"ğŸ“Š æœ€ç»ˆä½™é¢: {final_account.balance}")

# æµ‹è¯•é«˜çº§äº‹åŠ¡
# advanced_service = AdvancedTransactionService()
# advanced_service.complex_business_operation()
# advanced_service.demonstrate_transaction_isolation()
```

### **2. åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼**

```python
class DistributedTransactionCoordinator:
    """åˆ†å¸ƒå¼äº‹åŠ¡åè°ƒå™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
    
    def __init__(self):
        self.participants = []
    
    def prepare_phase(self, services: list) -> bool:
        """å‡†å¤‡é˜¶æ®µï¼šæ‰€æœ‰å‚ä¸è€…å‡†å¤‡æäº¤"""
        print("ğŸ”„ åˆ†å¸ƒå¼äº‹åŠ¡å‡†å¤‡é˜¶æ®µ...")
        
        for service in services:
            try:
                # æ¨¡æ‹Ÿå‡†å¤‡æ“ä½œ
                if not service.prepare():
                    return False
            except Exception as e:
                print(f"âŒ å‚ä¸è€…å‡†å¤‡å¤±è´¥: {e}")
                return False
        
        print("âœ… æ‰€æœ‰å‚ä¸è€…å‡†å¤‡å°±ç»ª")
        return True
    
    def commit_phase(self, services: list) -> bool:
        """æäº¤é˜¶æ®µï¼šæ‰€æœ‰å‚ä¸è€…æäº¤"""
        print("ğŸ”„ åˆ†å¸ƒå¼äº‹åŠ¡æäº¤é˜¶æ®µ...")
        
        for service in services:
            try:
                service.commit()
            except Exception as e:
                print(f"âŒ å‚ä¸è€…æäº¤å¤±è´¥: {e}")
                # è¿™é‡Œåº”è¯¥è¿›å…¥å›æ»šé˜¶æ®µ
                self.rollback_phase(services)
                return False
        
        print("âœ… åˆ†å¸ƒå¼äº‹åŠ¡æäº¤å®Œæˆ")
        return True
    
    def rollback_phase(self, services: list) -> bool:
        """å›æ»šé˜¶æ®µï¼šæ‰€æœ‰å‚ä¸è€…å›æ»š"""
        print("ğŸ”„ åˆ†å¸ƒå¼äº‹åŠ¡å›æ»šé˜¶æ®µ...")
        
        for service in services:
            try:
                service.rollback()
            except Exception as e:
                print(f"âŒ å‚ä¸è€…å›æ»šå¤±è´¥: {e}")
        
        print("âœ… åˆ†å¸ƒå¼äº‹åŠ¡å›æ»šå®Œæˆ")
        return True
    
    def execute_distributed_transaction(self, services: list) -> bool:
        """æ‰§è¡Œä¸¤é˜¶æ®µæäº¤åè®®"""
        print("ğŸš€ å¼€å§‹åˆ†å¸ƒå¼äº‹åŠ¡...")
        
        # ç¬¬ä¸€é˜¶æ®µï¼šå‡†å¤‡
        if not self.prepare_phase(services):
            self.rollback_phase(services)
            return False
        
        # ç¬¬äºŒé˜¶æ®µï¼šæäº¤
        if not self.commit_phase(services):
            return False
        
        return True

class MockDistributedService:
    """æ¨¡æ‹Ÿåˆ†å¸ƒå¼æœåŠ¡"""
    
    def __init__(self, name: str):
        self.name = name
        self.prepared = False
        self.committed = False
    
    def prepare(self) -> bool:
        """å‡†å¤‡é˜¶æ®µ"""
        print(f"  å‡†å¤‡ {self.name}...")
        # æ¨¡æ‹Ÿéšæœºå¤±è´¥
        import random
        if random.random() < 0.3:  # 30%æ¦‚ç‡å¤±è´¥
            return False
        
        self.prepared = True
        return True
    
    def commit(self):
        """æäº¤"""
        print(f"  æäº¤ {self.name}...")
        self.committed = True
    
    def rollback(self):
        """å›æ»š"""
        print(f"  å›æ»š {self.name}...")
        self.prepared = False

def test_distributed_transaction():
    """æµ‹è¯•åˆ†å¸ƒå¼äº‹åŠ¡"""
    print("=== åˆ†å¸ƒå¼äº‹åŠ¡æµ‹è¯• ===")
    
    coordinator = DistributedTransactionCoordinator()
    
    # åˆ›å»ºæ¨¡æ‹ŸæœåŠ¡
    services = [
        MockDistributedService("é“¶è¡ŒæœåŠ¡"),
        MockDistributedService("åº“å­˜æœåŠ¡"),
        MockDistributedService("ç‰©æµæœåŠ¡")
    ]
    
    # æ‰§è¡Œåˆ†å¸ƒå¼äº‹åŠ¡
    success = coordinator.execute_distributed_transaction(services)
    
    print(f"ğŸ“Š åˆ†å¸ƒå¼äº‹åŠ¡ç»“æœ: {'æˆåŠŸ' if success else 'å¤±è´¥'}")
    for service in services:
        print(f"  {service.name}: å‡†å¤‡={service.prepared}, æäº¤={service.committed}")

# test_distributed_transaction()
```

---

## ğŸ¯ **äº‹åŠ¡æœ€ä½³å®è·µæ€»ç»“**

### **äº‹åŠ¡è®¾è®¡åŸåˆ™**

| åŸåˆ™ | è¯´æ˜ | å®è·µå»ºè®® |
|------|------|----------|
| **ä¿æŒäº‹åŠ¡ç®€çŸ­** | å‡å°‘é”ç«äº‰æ—¶é—´ | ä¸šåŠ¡é€»è¾‘å‰ç½®éªŒè¯ |
| **åˆç†è®¾ç½®éš”ç¦»çº§åˆ«** | å¹³è¡¡ä¸€è‡´æ€§å’Œæ€§èƒ½ | æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹© |
| **ä½¿ç”¨ä¹è§‚é”** | é«˜å¹¶å‘è¯»åœºæ™¯ | ç‰ˆæœ¬å·æˆ–æ—¶é—´æˆ³ |
| **æ‚²è§‚é”è°¨æ…ä½¿ç”¨** | é¿å…æ­»é” | é”é¡ºåºä¸€è‡´æ€§ |

### **å¹¶å‘æ§åˆ¶ç­–ç•¥é€‰æ‹©**

```python
# ç­–ç•¥é€‰æ‹©æŒ‡å—
CONCURRENCY_STRATEGIES = {
    "high_read_low_write": "ä¹è§‚é”",
    "high_write_low_read": "æ‚²è§‚é”", 
    "mixed_workload": "æ··åˆç­–ç•¥",
    "distributed_system": "åˆ†å¸ƒå¼äº‹åŠ¡"
}

def select_concurrency_strategy(workload_type: str, consistency_requirement: str) -> str:
    """æ ¹æ®å·¥ä½œè´Ÿè½½é€‰æ‹©å¹¶å‘ç­–ç•¥"""
    strategies = {
        ("high_read", "strong"): "ä¹è§‚é” + é‡è¯•æœºåˆ¶",
        ("high_write", "strong"): "æ‚²è§‚é” + é˜Ÿåˆ—",
        ("balanced", "eventual"): "æ— é” + å†²çªè§£å†³",
        ("distributed", "strong"): "ä¸¤é˜¶æ®µæäº¤"
    }
    
    return strategies.get((workload_type, consistency_requirement), "é»˜è®¤æ‚²è§‚é”")
```