## 依赖注入(Dependency Injection)理解

### 什么是依赖注入

依赖注入是一种设计模式，用于实现控制反转(Inversion of Control, IoC)，通过将对象的依赖关系从内部创建转移到外部提供，实现代码的解耦和更好的可测试性。

### 核心概念

1. **依赖(Dependency)**：一个类执行其功能所需要的对象或服务
2. **注入(Injection)**：通过构造函数、方法参数或属性将依赖传递给类
3. **控制反转**：类不主动创建依赖，而是被动接收依赖

### 依赖注入的三种方式

#### 1. 构造函数注入(Constructor Injection)
```python
class OrderProcessor:
    def __init__(self, pricing_strategy: PricingStrategy):
        # 依赖通过构造函数注入
        self._pricing_strategy = pricing_strategy
    
    def process_order(self, order: Order) -> float:
        return self._pricing_strategy.calculate_price(order)
```

#### 2. 属性注入(Property Injection)
```python
class OrderProcessor:
    def __init__(self):
        self._pricing_strategy = None
    
    @property
    def pricing_strategy(self):
        return self._pricing_strategy
    
    @pricing_strategy.setter
    def pricing_strategy(self, strategy: PricingStrategy):
        # 依赖通过属性注入
        self._pricing_strategy = strategy
```

#### 3. 方法注入(Method Injection)
```python
class OrderProcessor:
    def process_order(self, order: Order, pricing_strategy: PricingStrategy) -> float:
        # 依赖通过方法参数注入
        return pricing_strategy.calculate_price(order)
```

---

在 strategy_demo.py 中，策略模式本身就体现了依赖注入的思想：

```python
class OrderProcessor:
    def __init__(self):
        # 内部初始化策略（不是最佳实践）
        self._strategies = {
            "regular": RegularPricingStrategy(),
            "vip": VIPPricingStrategy(),
            "premium": PremiumPricingStrategy()
        }
        self._current_strategy = self._strategies["regular"]
    
    # 更好的方式是通过注入来提供策略
    def set_strategy(self, strategy: PricingStrategy):
        # 方法注入：通过方法参数注入依赖
        self._current_strategy = strategy
```

### 依赖注入的优势

1. **解耦合**
   - 类不需要知道如何创建依赖，只需知道如何使用它们
   - 降低了类之间的耦合度

2. **提高可测试性**
   - 可以轻松注入模拟对象(mock)进行单元测试
   - 不需要真实的数据库连接、网络服务等

3. **提高可扩展性**
   - 可以轻松替换依赖的实现
   - 支持插件化架构

4. **便于管理复杂依赖**
   - 大型应用中对象依赖关系复杂，DI容器可以自动管理

### 实际应用示例

```python
# 传统方式 - 紧耦合
class OrderProcessor:
    def __init__(self):
        self.email_service = EmailService()  # 直接创建依赖
        self.payment_service = PaymentService()
    
    def process_order(self, order):
        # 处理订单
        self.payment_service.charge(order)
        self.email_service.send_confirmation(order)

# 依赖注入方式 - 松耦合
class OrderProcessor:
    def __init__(self, email_service, payment_service):
        # 通过构造函数注入依赖
        self.email_service = email_service
        self.payment_service = payment_service
    
    def process_order(self, order):
        self.payment_service.charge(order)
        self.email_service.send_confirmation(order)

# 使用时
email_service = MockEmailService()  # 测试时可以使用模拟对象
payment_service = MockPaymentService()
processor = OrderProcessor(email_service, payment_service)
```

### 依赖注入容器

在更复杂的系统中，通常会使用依赖注入容器来自动化管理依赖关系：

```python
# 简单的DI容器示例
class DIContainer:
    def __init__(self):
        self._services = {}
    
    def register(self, name, service):
        self._services[name] = service
    
    def get(self, name):
        return self._services[name]

# 使用
container = DIContainer()
container.register('email_service', EmailService())
container.register('payment_service', PaymentService())

# 获取服务时，容器自动处理依赖关系
processor = OrderProcessor(
    container.get('email_service'),
    container.get('payment_service')
)
```

依赖注入本质上是一种让代码更加灵活、可测试和可维护的设计原则，它将对象的创建和使用分离，使代码结构更加清晰。