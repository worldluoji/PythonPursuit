## 依赖注入：明确的依赖关系
**依赖注入** 的核心思想是：**一个类不应该自己创建它所依赖的对象，而应该由外部“注入”给它。** 这个“外部”通常由**框架的容器**或**调用者**来承担。

让我们用连接池例子，来看依赖注入的三种常见形式（以构造函数注入最为典型）：

```python
# 假设我们有一个连接池
class DatabaseConnectionPool:
    def get_connection(self):
        # 返回一个可用连接
        return connection

# 方式一：构造函数注入 （最推荐，依赖关系明确）
class UserService:
    def __init__(self, db_pool: DatabaseConnectionPool):  # 依赖通过参数声明并传入
        self.db_pool = db_pool

    def get_user(self, user_id):
        connection = self.db_pool.get_connection()
        # ... 使用 connection 查询
        return user

# 使用时：
pool = DatabaseConnectionPool()
service = UserService(db_pool=pool)  # 依赖被“注入”了

# 方式二：在FastAPI中，利用其内置的依赖注入系统
from fastapi import Depends

def get_db_pool() -> DatabaseConnectionPool:
    # 通常这里会从应用状态或设置中返回全局唯一的连接池
    return app.state.db_pool

@app.get(“/users/{user_id}“)
async def get_user(
    user_id: int,
    # FastAPI 会自动调用 get_db_pool 并将结果注入到 db_pool 参数中
    db_pool: DatabaseConnectionPool = Depends(get_db_pool)
):
    user_service = UserService(db_pool)  # 然后我们用它来构造服务
    return user_service.get_user(user_id)
```

### 依赖注入带来的核心优势
1.  **松耦合**：`UserService` 不再关心 `DatabaseConnectionPool` 是如何创建的。它只依赖于一个抽象（接口或基类），而不是具体实现。这符合**依赖倒置原则**。
2.  **可测试性**：在测试 `UserService` 时，您可以轻松地传入一个**模拟对象**来替代真实的数据库连接池，从而隔离测试，让测试更快、更稳定。
3.  **可维护性与可读性**：类的所有依赖都明确地在构造函数或方法签名中列出，一目了然。代码的职责更加清晰。
4.  **资源共享与生命周期管理**：依赖注入框架（如FastAPI的`Depends`）可以轻松管理像连接池这样的**单例**依赖，确保整个应用共享同一个实例，并可以在应用启动/关闭时统一初始化和清理。

### 总结
**依赖注入**是确保我们能以**最优雅、最规范的方式**将连接池（或任何其他依赖）提供给需要它的组件（如`UserService`）的设计模式。

FastAPI将这一模式作为框架的**一等公民**，使得管理数据库会话、认证、配置等变得异常简单和清晰。