FastAPI的 `fastapi.security` 模块让这一切变得异常简洁。

### 1. 完善依赖项：返回 **用户模型**
依赖项验证成功后，**直接返回解码出的用户信息对象**，而不仅仅是一个布尔值。这样路径操作函数就能立即使用用户身份。

我们首先可以定义一个Pydantic模型来表示当前用户：
```python
from pydantic import BaseModel

class CurrentUser(BaseModel):
    id: int
    username: str
    # 可以添加更多字段，如角色、权限等
```

### 2. 实现依赖项函数 `get_current_user`
我们将使用 `fastapi.security` 中的 `HTTPBearer` 来简化请求头提取，并假设我们使用 `python-jose` 库来验证JWT。

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from pydantic import BaseModel

# 1. 定义用户模型
class CurrentUser(BaseModel):
    id: int
    username: str

# 2. 创建 Bearer 模式实例，用于自动提取 `Authorization: Bearer <token>` 头
security_scheme = HTTPBearer()

# 3. 密钥和算法（实际应从环境变量或配置中读取）
SECRET_KEY = “your-secret-key-change-this”
ALGORITHM = “HS256”

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security_scheme)
) -> CurrentUser:
    """
    核心依赖项：
    1. 依赖 `security_scheme` 自动提取凭证。
    2. 验证JWT令牌。
    3. 返回当前用户模型。
    """
    token = credentials.credentials
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail=“无效的认证凭证”,
        headers={“WWW-Authenticate”: “Bearer”},
    )
    try:
        # 解码并验证令牌
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: int = payload.get(“sub”) # 通常‘sub’字段存放用户ID
        username: str = payload.get(“username”)
        if user_id is None or username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    # 返回用户模型，注入到路径操作函数
    return CurrentUser(id=user_id, username=username)
```

### 3. 在路径操作中使用依赖项
现在，在您的端点中，您可以**直接获取到当前用户对象**：

```python
from fastapi import Depends

@app.patch(“/orders/{order_id}”)
async def cancel_order(
    order_id: int,
    current_user: CurrentUser = Depends(get_current_user), # 注入已认证的用户
    db: Session = Depends(get_db) # 同样可以注入数据库会话
):
    # 1. 业务逻辑：先查询订单
    order = db.query(Order).filter(Order.id == order_id).first()
    if not order:
        raise HTTPException(status_code=404, detail=“订单不存在”)

    # 2. 授权判断：当前用户是否是订单所有者？
    if order.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail=“无权操作此订单”)

    # 3. 执行取消订单的业务逻辑...
    order.status = “cancelled”
    db.commit()
    return {“msg”: “订单已取消”, “order_id”: order_id}
```

### 关键优势与总结
通过这种方式，我们实现了：
- **关注点分离**：认证逻辑 (`get_current_user`) 与业务逻辑 (`cancel_order`) 完全分离。
- **可复用性**：在任意需要认证的端点上，只需添加 `current_user: CurrentUser = Depends(get_current_user)`。
- **安全与一致性**：认证失败会由依赖项统一抛出 `401` 异常。业务函数只需关心**授权**（当前用户是否有权操作特定资源）。
- **强类型与智能提示**：`current_user` 具有明确的 `CurrentUser` 类型，方便使用和静态检查。


---

## 基于OAuth2密码流的JWT认证流程

整个流程遵循一个清晰的标准模式，通常被称为 **“密码授权模式”** ，它特别适合受信任的第一方客户端（如你自己的前端或移动应用）：

```
1. 用户提交用户名和密码 -> 登录端点
2. 服务器验证凭证，若成功 -> 签发一个签名的JWT令牌
3. 客户端保存此令牌 -> 在后续请求的`Authorization`头中携带
4. 服务器在依赖项中验证此令牌 -> 提取用户身份
```

### 第一步：设计登录端点
登录端点需要接收用户名和密码，验证后返回令牌。FastAPI的 `fastapi.security` 模块提供了 `OAuth2PasswordRequestForm` 来简化接收标准格式的表单数据。

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from jose import jwt

from .dependencies import get_db  # 假设的数据库依赖
from .models import User  # 假设的用户ORM模型
from .schemas import Token  # 用于响应的令牌模型
from .core.security import verify_password, create_access_token  # 工具函数

router = APIRouter()

# 配置（应从环境变量读取）
SECRET_KEY = “your-secret-key”
ALGORITHM = “HS256”
ACCESS_TOKEN_EXPIRE_MINUTES = 30

@router.post(“/token”, response_model=Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """
    标准OAuth2密码流登录端点。
    路径通常约定为 `/token`，接收表单数据，返回访问令牌。
    """
    # 1. 验证用户凭证
    user = db.query(User).filter(User.username == form_data.username).first()
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=“用户名或密码错误”,
            headers={“WWW-Authenticate”: “Bearer”},
        )

    # 2. 创建访问令牌
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={“sub”: str(user.id), “username”: user.username},  # ‘sub’通常是用户标识
        secret_key=SECRET_KEY,
        algorithm=ALGORITHM,
        expires_delta=access_token_expires
    )

    # 3. 返回令牌（标准OAuth2响应格式）
    return {“access_token”: access_token, “token_type”: “bearer”}
```

### 第二步：支持函数与模型
上面的代码依赖于几个关键的组件：

1.  **令牌响应模型** (Pydantic Schema)：
    ```python
    from pydantic import BaseModel

    class Token(BaseModel):
        access_token: str
        token_type: str
    ```

2.  **密码验证工具函数** (示例)：
    ```python
    from passlib.context import CryptContext

    pwd_context = CryptContext(schemes=[“bcrypt”], deprecated=“auto”)

    def verify_password(plain_password, hashed_password):
        return pwd_context.verify(plain_password, hashed_password)
    ```

3.  **创建JWT令牌的工具函数**：
    ```python
    from datetime import datetime, timedelta
    from jose import jwt

    def create_access_token(
        data: dict, secret_key: str, algorithm: str, expires_delta: timedelta | None = None
    ):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)
        to_encode.update({“exp”: expire})
        encoded_jwt = jwt.encode(to_encode, secret_key, algorithm=algorithm)
        return encoded_jwt
    ```

### 完整流程回顾
现在，您拥有了一个完整的、生产可用的认证流程：

| 步骤 | 端点/组件 | 输入 | 输出 | 作用 |
| :--- | :--- | :--- | :--- | :--- |
| **1. 登录** | `POST /token` | `username` & `password` (表单) | `{“access_token”: “jwt...”, “token_type”: “bearer”}` | 验证凭证，签发短期访问令牌。 |
| **2. 受保护请求** | 任何API，如 `PATCH /orders/{id}` | `Authorization: Bearer <jwt>` | 业务数据 | 客户端在所有后续请求头中携带令牌。 |
| **3. 自动验证** | `get_current_user` 依赖项 | 同上 | `CurrentUser` 对象或 `401` 错误 | 自动截取、验证令牌，提取用户身份并注入业务函数。 |

### 关键安全实践
*   **永远哈希密码**：在数据库中只存储使用强哈希算法（如bcrypt）处理后的密码哈希值。
*   **令牌有效期**：访问令牌应设置较短的有效期（如30分钟），以降低泄露风险。可通过刷新令牌机制来获取新令牌。
*   **HTTPS**：在生产环境中，**必须**使用HTTPS来加密传输密码和令牌，防止中间人攻击。


---


## RBAC（基于角色的访问控制）
*   **解耦**：认证（验证用户身份）和授权（检查用户权限）成为两个独立的、可单独测试和复用的组件。
*   **灵活性**：可以轻松组合不同的权限依赖项（如`require_admin`、`require_owner`），甚至创建更复杂的权限检查链。
*   **清晰性**：在路径操作函数的参数列表中，依赖项的意图一目了然（例如，`Depends(require_admin)` 明确表示此端点需要管理员权限）。

### 实现方案：基于角色的访问控制

#### 步骤1：扩展用户模型以包含角色信息
首先，需要在用户认证时获取其角色信息，并包含在`CurrentUser`对象中。

```python
from pydantic import BaseModel
from enum import Enum

# 定义角色枚举，明确系统中的所有角色
class UserRole(str, Enum):
    GUEST = “guest”
    USER = “user”  # 普通注册用户
    ADMIN = “admin”
    SUPER_ADMIN = “super_admin”

# 增强的当前用户模型
class CurrentUser(BaseModel):
    id: int
    username: str
    roles: list[UserRole]  # 用户可能拥有多个角色
```

在您的 `get_current_user` 依赖项中，解码JWT令牌时，需要将存储在令牌中的角色信息也解析出来，并填充到 `CurrentUser` 对象的 `roles` 字段中。

#### 步骤2：创建专用的权限依赖项
这是核心的“专注于权限的依赖项”。它将依赖（并消费）`get_current_user` 返回的 `CurrentUser` 对象，并基于此进行权限判断。

```python
from fastapi import Depends, HTTPException, status
from typing import Sequence

async def get_current_user_with_roles(
    current_user: CurrentUser = Depends(get_current_user)  # 首先依赖认证
) -> CurrentUser:
    “”“这个依赖项只是确保获取到带有角色信息的用户对象，可以直接返回给需要用户信息的端点使用。”“”
    return current_user

def require_roles(allowed_roles: Sequence[UserRole]):
    “”“
    工厂函数：返回一个权限检查依赖项。
    它会检查当前用户的角色是否在允许的角色列表中。
    ”“”
    async def role_checker(
        current_user: CurrentUser = Depends(get_current_user_with_roles)
    ) -> CurrentUser:
        # 检查用户是否拥有任一被允许的角色
        if not any(role in current_user.roles for role in allowed_roles):
            # 如果用户没有任何所需角色，抛出 403 禁止访问错误
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=“权限不足，访问被拒绝”
            )
        # 权限检查通过，返回用户对象，供后续可能的业务逻辑使用
        return current_user
    return role_checker

# 为了方便使用，可以预定义一些常用的权限依赖项
require_admin = require_roles([UserRole.ADMIN, UserRole.SUPER_ADMIN])  # 允许管理员和超级管理员
require_super_admin = require_roles([UserRole.SUPER_ADMIN])           # 仅允许超级管理员
require_any_user = require_roles([UserRole.USER, UserRole.ADMIN, UserRole.SUPER_ADMIN]) # 禁止访客
```

#### 步骤3：在端点中组合使用
现在，您可以在路径操作函数中，像使用其他依赖项一样，注入这些权限检查器。

```python
from fastapi import Depends, APIRouter
from .schemas import OrderDetail

router = APIRouter()

@router.patch(“/orders/{order_id}“, response_model=OrderDetail)
async def cancel_order(
    order_id: int,
    # 权限依赖项：要求用户是‘USER’（订单所有者检查在业务逻辑里）或是‘ADMIN’/‘SUPER_ADMIN’
    _authorized_user: CurrentUser = Depends(require_roles([UserRole.USER, UserRole.ADMIN, UserRole.SUPER_ADMIN])),
    db: Session = Depends(get_db)
):
    “”“取消订单（允许订单所有者或管理员）”“”
    order = db.query(Order).filter(Order.id == order_id).first()
    if not order:
        raise HTTPException(status_code=404, detail=“订单不存在”)

    # 业务授权逻辑：如果是普通用户，必须是订单所有者；管理员则无此限制
    user = _authorized_user
    if UserRole.USER in user.roles and order.owner_id != user.id:
        raise HTTPException(status_code=403, detail=“无权操作此订单”)

    # 执行取消逻辑...
    return order

@router.delete(“/system/users/{user_id}“)
async def delete_user(
    user_id: int,
    # 权限依赖项：此操作仅允许超级管理员
    _super_admin: CurrentUser = Depends(require_super_admin),
    db: Session = Depends(get_db)
):
    “”“删除用户（仅超级管理员）”“”
    # 由于依赖项已确保当前用户是超级管理员，这里可以直接执行业务逻辑
    # ...
    return {“msg”: “用户已删除”}
```

### 方案优势总结
1.  **高度解耦**：认证 (`get_current_user`)、角色检查 (`require_roles`)、业务授权（订单所有者检查）彼此独立，职责清晰。
2.  **声明式与可复用**：端点通过声明需要的依赖项来定义其权限要求，`require_admin` 等依赖项可以在任何需要的地方复用。
3.  **易于测试**：可以独立测试权限依赖项的逻辑，而无需启动完整的API。
4.  **易于扩展**：如果需要更复杂的权限逻辑（如基于权限字符串、属性基访问控制ABAC），只需创建新的依赖项工厂函数即可，无需修改现有端点的结构。
