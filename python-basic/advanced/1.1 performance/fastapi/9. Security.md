FastAPI的 `fastapi.security` 模块让这一切变得异常简洁。

### 1. 完善依赖项：返回 **用户模型**
依赖项验证成功后，**直接返回解码出的用户信息对象**，而不仅仅是一个布尔值。这样路径操作函数就能立即使用用户身份。

我们首先可以定义一个Pydantic模型来表示当前用户：
```python
from pydantic import BaseModel

class CurrentUser(BaseModel):
    id: int
    username: str
    # 可以添加更多字段，如角色、权限等
```

### 2. 实现依赖项函数 `get_current_user`
我们将使用 `fastapi.security` 中的 `HTTPBearer` 来简化请求头提取，并假设我们使用 `python-jose` 库来验证JWT。

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from pydantic import BaseModel

# 1. 定义用户模型
class CurrentUser(BaseModel):
    id: int
    username: str

# 2. 创建 Bearer 模式实例，用于自动提取 `Authorization: Bearer <token>` 头
security_scheme = HTTPBearer()

# 3. 密钥和算法（实际应从环境变量或配置中读取）
SECRET_KEY = “your-secret-key-change-this”
ALGORITHM = “HS256”

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security_scheme)
) -> CurrentUser:
    """
    核心依赖项：
    1. 依赖 `security_scheme` 自动提取凭证。
    2. 验证JWT令牌。
    3. 返回当前用户模型。
    """
    token = credentials.credentials
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail=“无效的认证凭证”,
        headers={“WWW-Authenticate”: “Bearer”},
    )
    try:
        # 解码并验证令牌
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: int = payload.get(“sub”) # 通常‘sub’字段存放用户ID
        username: str = payload.get(“username”)
        if user_id is None or username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    # 返回用户模型，注入到路径操作函数
    return CurrentUser(id=user_id, username=username)
```

### 3. 在路径操作中使用依赖项
现在，在您的端点中，您可以**直接获取到当前用户对象**：

```python
from fastapi import Depends

@app.patch(“/orders/{order_id}”)
async def cancel_order(
    order_id: int,
    current_user: CurrentUser = Depends(get_current_user), # 注入已认证的用户
    db: Session = Depends(get_db) # 同样可以注入数据库会话
):
    # 1. 业务逻辑：先查询订单
    order = db.query(Order).filter(Order.id == order_id).first()
    if not order:
        raise HTTPException(status_code=404, detail=“订单不存在”)

    # 2. 授权判断：当前用户是否是订单所有者？
    if order.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail=“无权操作此订单”)

    # 3. 执行取消订单的业务逻辑...
    order.status = “cancelled”
    db.commit()
    return {“msg”: “订单已取消”, “order_id”: order_id}
```

### 关键优势与总结
通过这种方式，我们实现了：
- **关注点分离**：认证逻辑 (`get_current_user`) 与业务逻辑 (`cancel_order`) 完全分离。
- **可复用性**：在任意需要认证的端点上，只需添加 `current_user: CurrentUser = Depends(get_current_user)`。
- **安全与一致性**：认证失败会由依赖项统一抛出 `401` 异常。业务函数只需关心**授权**（当前用户是否有权操作特定资源）。
- **强类型与智能提示**：`current_user` 具有明确的 `CurrentUser` 类型，方便使用和静态检查。


---

## 基于OAuth2密码流的JWT认证流程

整个流程遵循一个清晰的标准模式，通常被称为 **“密码授权模式”** ，它特别适合受信任的第一方客户端（如你自己的前端或移动应用）：

```
1. 用户提交用户名和密码 -> 登录端点
2. 服务器验证凭证，若成功 -> 签发一个签名的JWT令牌
3. 客户端保存此令牌 -> 在后续请求的`Authorization`头中携带
4. 服务器在依赖项中验证此令牌 -> 提取用户身份
```

### 第一步：设计登录端点
登录端点需要接收用户名和密码，验证后返回令牌。FastAPI的 `fastapi.security` 模块提供了 `OAuth2PasswordRequestForm` 来简化接收标准格式的表单数据。

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from jose import jwt

from .dependencies import get_db  # 假设的数据库依赖
from .models import User  # 假设的用户ORM模型
from .schemas import Token  # 用于响应的令牌模型
from .core.security import verify_password, create_access_token  # 工具函数

router = APIRouter()

# 配置（应从环境变量读取）
SECRET_KEY = “your-secret-key”
ALGORITHM = “HS256”
ACCESS_TOKEN_EXPIRE_MINUTES = 30

@router.post(“/token”, response_model=Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """
    标准OAuth2密码流登录端点。
    路径通常约定为 `/token`，接收表单数据，返回访问令牌。
    """
    # 1. 验证用户凭证
    user = db.query(User).filter(User.username == form_data.username).first()
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=“用户名或密码错误”,
            headers={“WWW-Authenticate”: “Bearer”},
        )

    # 2. 创建访问令牌
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={“sub”: str(user.id), “username”: user.username},  # ‘sub’通常是用户标识
        secret_key=SECRET_KEY,
        algorithm=ALGORITHM,
        expires_delta=access_token_expires
    )

    # 3. 返回令牌（标准OAuth2响应格式）
    return {“access_token”: access_token, “token_type”: “bearer”}
```

### 第二步：支持函数与模型
上面的代码依赖于几个关键的组件：

1.  **令牌响应模型** (Pydantic Schema)：
    ```python
    from pydantic import BaseModel

    class Token(BaseModel):
        access_token: str
        token_type: str
    ```

2.  **密码验证工具函数** (示例)：
    ```python
    from passlib.context import CryptContext

    pwd_context = CryptContext(schemes=[“bcrypt”], deprecated=“auto”)

    def verify_password(plain_password, hashed_password):
        return pwd_context.verify(plain_password, hashed_password)
    ```

3.  **创建JWT令牌的工具函数**：
    ```python
    from datetime import datetime, timedelta
    from jose import jwt

    def create_access_token(
        data: dict, secret_key: str, algorithm: str, expires_delta: timedelta | None = None
    ):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)
        to_encode.update({“exp”: expire})
        encoded_jwt = jwt.encode(to_encode, secret_key, algorithm=algorithm)
        return encoded_jwt
    ```

### 完整流程回顾
现在，您拥有了一个完整的、生产可用的认证流程：

| 步骤 | 端点/组件 | 输入 | 输出 | 作用 |
| :--- | :--- | :--- | :--- | :--- |
| **1. 登录** | `POST /token` | `username` & `password` (表单) | `{“access_token”: “jwt...”, “token_type”: “bearer”}` | 验证凭证，签发短期访问令牌。 |
| **2. 受保护请求** | 任何API，如 `PATCH /orders/{id}` | `Authorization: Bearer <jwt>` | 业务数据 | 客户端在所有后续请求头中携带令牌。 |
| **3. 自动验证** | `get_current_user` 依赖项 | 同上 | `CurrentUser` 对象或 `401` 错误 | 自动截取、验证令牌，提取用户身份并注入业务函数。 |

### 关键安全实践
*   **永远哈希密码**：在数据库中只存储使用强哈希算法（如bcrypt）处理后的密码哈希值。
*   **令牌有效期**：访问令牌应设置较短的有效期（如30分钟），以降低泄露风险。可通过刷新令牌机制来获取新令牌。
*   **HTTPS**：在生产环境中，**必须**使用HTTPS来加密传输密码和令牌，防止中间人攻击。