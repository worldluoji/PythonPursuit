# __repr__VS__str__
`__repr__` 和 `__str__` 是 Python 中两个不同的魔术方法，它们有不同的用途和调用场景：

## 主要区别

### 1. **目的和用途**

- `__repr__`: 官方称为"official string representation"，应该是**无歧义的**，尽可能准确地表示对象的内部状态，主要用于调试和开发
- `__str__`: 官方称为"informal string representation"，应该是**可读性强的**，面向最终用户的字符串表示

### 2. **调用场景**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"
    
    def __str__(self):
        return f"{self.name}, {self.age} years old"

person = Person("Alice", 30)

# __repr__ 调用场景
print(repr(person))        # Person(name='Alice', age=30)
print([person])            # [Person(name='Alice', age=30)]
person                     # 在交互式解释器中显示

# __str__ 调用场景  
print(str(person))         # Alice, 30 years old
print(person)              # Alice, 30 years old
f"{person}"                # Alice, 30 years old
```

### 3. **默认行为**

```python
class Example:
    def __init__(self, value):
        self.value = value

obj = Example(42)
print(repr(obj))  # <__main__.Example object at 0x...>
print(str(obj))   # <__main__.Example object at 0x...>

# 默认情况下，两者都返回对象的地址信息
```

### 4. **最佳实践**

#### `__repr__`应该：
- 尽可能准确、无歧义
- 如果可能，返回的字符串应该能够重新创建对象
- 通常包含类名和关键属性

```python
def __repr__(self):
    return f"Point(x={self.x}, y={self.y})"  # 可以用来重建对象
```

#### `__str__` 应该：
- 注重可读性和用户体验
- 返回对用户友好的描述

```python
def __str__(self):
    return f"Point at ({self.x}, {self.y})"
```

### 5. **在 `@dataclass` 中的表现**

```python
from dataclasses import dataclass

@dataclass
class Product:
    name: str
    price: float

product = Product("iPhone", 999.99)

# @dataclass 自动生成的 __repr__
print(repr(product))  # Product(name='iPhone', price=999.99)

# @dataclass 不会自动生成 __str__，如果没有定义则回退到 __repr__
print(str(product))   # Product(name='iPhone', price=999.99)
print(product)        # Product(name='iPhone', price=999.99)
```

### 6. **在您的 SQL 查询例子中**

```python
# 您的 SQLQuery 类已经定义了 __str__
def __str__(self):
    query = f"SELECT {self.select} FROM {self.table}"
    if self.where_conditions:
        query += f" WHERE {' AND '.join(self.where_conditions)}"
    if self.limit_value:
        query += f" LIMIT {self.limit_value}"
    return query

# 如果使用 @dataclass 自动生成的 __repr__
# 会得到类似: PythonicSQLQuery(select='*', table='', where_conditions=[], limit_value=None)

# 而 __str__ 会得到类似: SELECT * FROM users WHERE age > 18 LIMIT 10
```

## 总结

| 特性 | [__repr__] | [__str__] |
|------|------------|-----------|
| 主要用途 | 开发/调试 | 用户展示 |
| 调用方法 | `repr()`, 容器显示 | `str()`, `print()` |
| 默认行为 | 对象地址 | 继承自 [__repr__] |
| 设计目标 | 准确无歧义 | 可读性好 |

如果只实现其中一个，建议优先实现 [__repr__]，因为 [__str__] 默认会调用 [__repr__]。