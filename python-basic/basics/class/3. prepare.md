# prepare
在 Python 3 中，`__prepare__` 是一个特殊的类方法，用于控制类命名空间（namespace）的创建过程。让我详细讲解一下它的作用和使用方法。

## 基本概念

`__prepare__` 是元类（metaclass）的一个方法，它在类创建过程的开始阶段被调用，用于返回一个用于存储类属性的映射对象（通常是字典）。

## 语法和调用时机

```python
class MyMeta(type):
    @classmethod
    def __prepare__(metacls, name, bases, **kwargs):
        # 返回一个映射对象（如 dict、OrderedDict 等）
        return {}
```

## 基本示例

```python
from collections import OrderedDict

class OrderedMeta(type):
    @classmethod
    def __prepare__(metacls, name, bases, **kwargs):
        # 使用 OrderedDict 来保持属性定义的顺序
        return OrderedDict()

class MyClass(metaclass=OrderedMeta):
    z = 3
    a = 1
    b = 2

# 查看属性定义顺序
print(list(MyClass.__dict__.keys()))
# 输出会保持 z, a, b 的顺序（而不是字母顺序）
```

## 实际应用场景

### 1. 保持属性定义顺序

```python
from collections import OrderedDict

class OrderedClass(type):
    @classmethod
    def __prepare__(cls, name, bases):
        return OrderedDict()
    
    def __new__(cls, name, bases, classdict):
        # 可以在这里访问有序的属性字典
        classdict['_creation_order'] = list(classdict.keys())
        return super().__new__(cls, name, bases, dict(classdict))

class MyOrderedClass(metaclass=OrderedClass):
    first = 1
    second = 2
    third = 3

print(MyOrderedClass._creation_order)
# 输出: ['__module__', '__qualname__', 'first', 'second', 'third']
```

### 2. 验证属性名

```python
class ValidatedMeta(type):
    @classmethod
    def __prepare__(cls, name, bases):
        # 返回一个自定义的字典来验证属性名
        return AttributeDict()
    
    def __new__(cls, name, bases, classdict):
        return super().__new__(cls, name, bases, dict(classdict))

class AttributeDict(dict):
    def __setitem__(self, key, value):
        if key.startswith('__') and key.endswith('__'):
            # 允许魔术方法
            pass
        elif not key.isidentifier():
            raise NameError(f"Invalid attribute name: {key}")
        super().__setitem__(key, value)

class ValidatedClass(metaclass=ValidatedMeta):
    valid_name = "ok"  # 正常
    # invalid-name = "error"  # 这会抛出 NameError
```

### 3. 自动注册类

```python
class RegistryMeta(type):
    registry = {}
    
    @classmethod
    def __prepare__(cls, name, bases):
        return {'_class_name': name}  # 预先添加一些属性
    
    def __new__(cls, name, bases, classdict):
        # 在创建类时自动注册
        new_class = super().__new__(cls, name, bases, classdict)
        cls.registry[name] = new_class
        return new_class

class BaseClass(metaclass=RegistryMeta):
    pass

class ClassA(BaseClass):
    pass

class ClassB(BaseClass):
    pass

print(RegistryMeta.registry)
# 输出: {'BaseClass': <class '__main__.BaseClass'>, 
#        'ClassA': <class '__main__.ClassA'>, 
#        'ClassB': <class '__main__.ClassB'>}
```

### 4. 带参数的 `__prepare__`

```python
class ConfigurableMeta(type):
    @classmethod
    def __prepare__(metacls, name, bases, **kwargs):
        # 可以接收额外的关键字参数
        namespace = {}
        namespace['_config'] = kwargs
        return namespace

class ConfigurableClass(metaclass=ConfigurableMeta, debug=True, version='1.0'):
    pass

print(ConfigurableClass._config)
# 输出: {'debug': True, 'version': '1.0'}
```

## 完整的工作流程

```python
class TracingMeta(type):
    @classmethod
    def __prepare__(metacls, name, bases, **kwargs):
        print(f"1. __prepare__ called for {name}")
        return {}
    
    def __new__(cls, name, bases, namespace, **kwargs):
        print(f"2. __new__ called for {name}")
        print(f"   Namespace: {list(namespace.keys())}")
        return super().__new__(cls, name, bases, namespace)
    
    def __init__(cls, name, bases, namespace, **kwargs):
        print(f"3. __init__ called for {name}")
        super().__init__(name, bases, namespace)

class ExampleClass(metaclass=TracingMeta):
    attr1 = 1
    attr2 = 2
    
    def method(self):
        return "hello"

# 输出顺序：
# 1. __prepare__ called for ExampleClass
# 2. __new__ called for ExampleClass
#    Namespace: ['__module__', '__qualname__', 'attr1', 'attr2', 'method']
# 3. __init__ called for ExampleClass
```

## 注意事项

1. `__prepare__` 必须是一个类方法（使用 `@classmethod` 装饰）
2. 返回值必须是一个映射对象（实现了 `__getitem__` 和 `__setitem__`）
3. 在 Python 3.6+ 中，普通的类定义已经默认保持属性顺序，但 `__prepare__` 仍然有用
4. 主要用于高级元编程场景，日常开发中很少需要直接使用

`__prepare__` 方法为 Python 的元类系统提供了强大的灵活性，允许开发者在类创建的最初阶段就介入并定制命名空间的行为。