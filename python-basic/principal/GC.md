# GC
Python的垃圾回收机制主要依赖**引用计数**作为基础，并结合**分代回收**来处理循环引用等复杂场景。两者的协同工作确保了内存高效回收，以下是详细原理及协作流程：

---

### **一、引用计数（Reference Counting）**
#### **1. 核心原理**
- **每个对象**内部维护一个计数器（`ob_refcnt`），记录当前指向该对象的引用数量。
- **引用增减规则**：
  - 对象被创建或被引用时，`ob_refcnt += 1`。
  - 引用被删除或超出作用域时，`ob_refcnt -= 1`。
- **即时回收**：当`ob_refcnt == 0`时，对象内存立即释放。

#### **2. 代码示例**
```python
a = [1, 2, 3]  # 引用计数 = 1
b = a          # 引用计数 = 2
del b          # 引用计数 = 1（a仍指向列表）
a = None       # 引用计数 = 0 → 列表被销毁
```

#### **3. 优点与缺陷**
- **优点**：实时性强，无停顿，内存立即回收。
- **缺陷**：无法处理循环引用。

---

### **二、分代回收（Generational GC）**
#### **1. 设计目标**
解决**循环引用**导致的内存泄漏。例如：
```python
class Node:
    def __init__(self):
        self.parent = None
        self.child = None

# 创建循环引用
a = Node()
b = Node()
a.child = b  # a.refcnt = 1, b.refcnt = 1
b.parent = a  # a.refcnt = 2, b.refcnt = 2
del a, b      # a.refcnt = 1, b.refcnt = 1 → 无法通过引用计数回收
```

#### **2. 分代策略**
- **对象分代**：
  - **第0代（Young）**：新创建的对象。
  - **第1代（Middle-aged）**：经历过一次GC存活的对象。
  - **第2代（Old）**：经历过多次GC仍存活的对象。
- **回收频率**：代数越高，GC触发频率越低（默认阈值：700, 10, 10）。

#### **3. 标记-清除（Mark-Sweep）流程**
1. **标记阶段**：
   - 从根对象（如全局变量、栈帧中的对象）出发，遍历所有可达对象。
   - 将可达对象标记为“存活”。
2. **清除阶段**：
   - 遍历堆内存，回收未被标记的对象（即不可达的循环引用）。

---

### **三、引用计数与分代回收的协同流程**
#### **1. 日常回收（引用计数主导）**
- **场景**：绝大多数对象通过引用计数即时回收。
- **示例**：
  ```python
  def func():
      data = [1, 2, 3]  # 引用计数 = 1
      # 函数结束 → data超出作用域 → 引用计数归零 → 立即回收
  ```

#### **2. 分代回收触发条件**
- **阈值触发**：当某一代的对象数量超过阈值时，启动该代的GC。
- **手动触发**：调用`gc.collect(generation)`。

#### **3. 处理循环引用（分代回收主导）**
- **步骤**：
  1. **暂停程序**（Stop-the-world）：确保对象图稳定。
  2. **标记存活对象**：遍历所有根对象，标记可达对象。
  3. **清除不可达对象**：回收未被标记的循环引用对象。
  4. **调整分代**：存活对象晋升到下一代。

#### **4. 协同工作示例**
```python
import gc

class Cycle:
    def __init__(self):
        self.cycle = self  # 自引用循环

# 创建循环引用
obj = Cycle()  # 引用计数 = 1（obj指向实例）
del obj        # 引用计数 = 0 → 引用计数回收？但实例内部存在自引用循环！

# 此时实例的引用计数为1（自引用），但已无外部引用
# 分代回收启动后，检测到该实例不可达 → 清除
gc.collect()  # 强制触发GC → 实例被回收
```

---

### **四、跨代引用与处理**
- **问题**：老年代对象可能引用新生代对象，导致GC误判。
- **解决方案**：
  - **写屏障（Write Barrier）**：记录跨代引用，确保GC时检查所有相关代。
  - 将跨代引用加入根对象集合，避免遗漏可达对象。

---

### **五、性能优化与注意事项**
#### **1. 避免循环引用**
- 使用弱引用（`weakref`）替代强引用：
  ```python
  import weakref

  class Node:
      def __init__(self):
          self.parent = weakref.ref(None)  # 弱引用
  ```

#### **2. 谨慎使用`__del__`方法**
- `__del__`会阻止GC回收对象，可能导致不可预测行为。
- 替代方案：使用上下文管理器（`with`语句）或`atexit`模块。

#### **3. 监控GC行为**
- 通过`gc`模块调试：
  ```python
  gc.set_debug(gc.DEBUG_STATS | gc.DEBUG_LEAK)  # 打印GC日志
  ```

---

### **六、总结**
- **引用计数**：实时处理简单内存回收，高效但无法处理循环引用。
- **分代回收**：周期性检测并清除循环引用，弥补引用计数的不足。
- **协同优势**：
  - 引用计数处理90%以上的内存回收。
  - 分代回收处理剩余的复杂场景（如循环引用）。
- **适用场景**：
  - 高频创建/销毁对象 → 引用计数主导。
  - 长期存活对象或循环引用 → 分代回收介入。
